generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
  VERY_HARD
  TRICKY
}

enum RoleEnum {
  SuperAdmin
  Admin
  SuperUser
  User
}

enum ExamStatus {
  Scheduled
  Active
  Inactive
  Completed
}

enum ParticipantStatus {
  NotStarted
  InProgress
  Completed
}

model Participant {
  id                  Int                     @id @default(autoincrement())
  name                String
  email               String                  @unique
  password            String
  mobileNumber        String                  @unique
  active              Boolean                 @default(true)
  batchId             Int?
  organizationId      Int
  organization        Organization            @relation(fields: [organizationId], references: [id])
  createdById         Int?
  createdBy           User?                   @relation("CreatedBy", fields: [createdById], references: [id])
  updatedById         Int?
  updatedBy           User?                   @relation("UpdatedBy", fields: [updatedById], references: [id])
  responses           Response[]
  results             Result[]
  createdAt           DateTime                @default(now())
  updatedAt           DateTime                @updatedAt
  approved            Boolean                 @default(false)
  visibility          Boolean                 @default(true)
  GroupParticipant    GroupParticipant[]
  ParticipantTracking ParticipantTracking[]
  User                User?                   @relation(fields: [userId], references: [id])
  userId              Int?
  WordCloudResponse   WordCloudResponse[]
  batch               UploadParticipantBatch? @relation(fields: [batchId], references: [id])
}

model User {
  id                     Int                      @id @default(autoincrement())
  name                   String
  email                  String                   @unique
  mobileNumber           String                   @unique
  password               String
  role                   RoleEnum
  organizationId         Int?
  createdById            Int?
  active                 Boolean                  @default(true)
  createdBy              User?                    @relation("CreatedUsers", fields: [createdById], references: [id])
  createdUsers           User[]                   @relation("CreatedUsers")
  createdExams           Exam[]                   @relation("AdminCreatedExam")
  updatedExams           Exam[]                   @relation("AdminUpdatedExam")
  questions              Question[]
  IntResponse            IntResponse[]
  Category               Category[]
  Topic                  Topic[]
  examsTaken             ExamParticipant[]
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @default(now())
  Organization           Organization?            @relation(fields: [organizationId], references: [id])
  Exam                   Exam[]
  Group                  Group[]
  GroupParticipant       GroupParticipant[]
  Participant            Participant[]
  GroupExam              GroupExam[]
  createdParticipants    Participant[]            @relation("CreatedBy")
  updatedParticipants    Participant[]            @relation("UpdatedBy")
  questionsCreated       Question[]               @relation("CreatedBy")
  questionsUpdated       Question[]               @relation("UpdatedBy")
  groupCreated           Group[]                  @relation("UpdatedBy")
  groupUpdated           Group[]                  @relation("CreatedBy")
  StagingQuestion        StagingQuestion[]
  WordCloudQuestion      WordCloudQuestion[]
  StagingParticipant     StagingParticipant[]
  UploadBatch            UploadBatch[]
  UploadParticipantBatch UploadParticipantBatch[]
  FileUploadSummary      FileUploadSummary[]
}

model Organization {
  id          Int           @id @default(autoincrement())
  name        String
  email       String        @unique
  phone       String
  address     String
  State       String
  Country     String
  CountryCode String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  User        User[]
  Group       Group[]
  Participant Participant[]
}

model Category {
  id        Int        @id @default(autoincrement())
  name      String
  adminId   Int?
  admin     User?      @relation(fields: [adminId], references: [id])
  questions Question[]
  topics    Topic[]

  @@unique([name, adminId]) // Composite unique constraint
}

model Topic {
  id         Int        @id @default(autoincrement())
  name       String
  categoryId Int
  adminId    Int?
  category   Category   @relation(fields: [categoryId], references: [id])
  admin      User?      @relation(fields: [adminId], references: [id])
  Question   Question[]

  @@unique([name, categoryId, adminId]) // Composite unique constraint
}

model Question {
  id            Int        @id @default(autoincrement())
  text          String
  categoryId    Int
  topicId       Int
  correctOption Int
  difficulty    Difficulty @default(MEDIUM)
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  adminId       Int?
  examId        Int?
  updatedBy     Int?
  visibility    Boolean    @default(true)
  batchId       Int?

  category          Category           @relation(fields: [categoryId], references: [id])
  topic             Topic              @relation(fields: [topicId], references: [id])
  options           Option[]
  admin             User?              @relation("CreatedBy", fields: [adminId], references: [id])
  updatedByAdmin    User?              @relation("UpdatedBy", fields: [updatedBy], references: [id])
  responses         Response[]
  Exam              Exam?              @relation(fields: [examId], references: [id])
  QuestionFrequency QuestionFrequency?
  IntResponse       IntResponse[]

  // NEW RELATION
  batch  UploadBatch? @relation(fields: [batchId], references: [id])
  User   User?        @relation(fields: [userId], references: [id])
  userId Int?
}

model Option {
  id         Int     @id @default(autoincrement())
  text       String
  questionId Int
  isCorrect  Boolean @default(false)

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

model QuestionFrequency {
  id         Int @id @default(autoincrement())
  questionId Int @unique
  useFreq    Int @default(0)
  rightFreq  Int @default(0)
  wrongFreq  Int @default(0)

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

model Exam {
  id               Int       @id @default(autoincrement())
  title            String
  description      String
  examCode         String    @unique
  duration         Int
  status           String
  startTime        DateTime? // Optional for unscheduled exams
  endTime          DateTime?
  createdByAdminId Int
  updatedByAdminId Int
  createdById      Int

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  visibility Boolean  @default(true)

  createdBy           User                 @relation("AdminCreatedExam", fields: [createdByAdminId], references: [id])
  updatedBy           User                 @relation("AdminUpdatedExam", fields: [updatedByAdminId], references: [id])
  createdByUser       User                 @relation(fields: [createdById], references: [id])
  questions           Question[]
  Response            Response[]
  Result              Result[]
  IntResponse         IntResponse[]
  participants        ExamParticipant[]
  GroupExam           GroupExam[]
  ScheduledExamBuffer ScheduledExamBuffer?
}

model ExamParticipant {
  id        Int               @id @default(autoincrement())
  examId    Int
  userId    Int
  startTime DateTime?
  endTime   DateTime?
  status    ParticipantStatus

  exam Exam @relation(fields: [examId], references: [id])
  user User @relation(fields: [userId], references: [id])
}

model Response {
  id             Int      @id @default(autoincrement())
  userId         Int
  examId         Int
  questionId     Int
  selectedOption Int
  isCorrect      Boolean
  createdAt      DateTime @default(now())

  user     Participant @relation(fields: [userId], references: [id])
  exam     Exam        @relation(fields: [examId], references: [id])
  question Question    @relation(fields: [questionId], references: [id])
}

model IntResponse {
  id         Int      @id @default(autoincrement())
  examId     Int
  questionId Int
  userId     Int
  text       String
  exam       Exam     @relation(fields: [examId], references: [id])
  user       User     @relation(fields: [userId], references: [id])
  question   Question @relation(fields: [questionId], references: [id])
}

model Result {
  id        Int         @id @default(autoincrement())
  userId    Int
  examId    Int
  score     Int
  total     Int
  createdAt DateTime    @default(now())
  user      Participant @relation(fields: [userId], references: [id])
  exam      Exam        @relation(fields: [examId], references: [id])

  @@unique([userId, examId])
}

model Group {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  startDate   DateTime
  endDate     DateTime
  isActive    Boolean  @default(true)

  createdById Int
  createdBy   User  @relation("CreatedBy", fields: [createdById], references: [id])
  updatedById Int?
  updatedBy   User? @relation("UpdatedBy", fields: [updatedById], references: [id])

  organizationId Int
  organization   Organization @relation(fields: [organizationId], references: [id])

  participants         GroupParticipant[]
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  visibility           Boolean               @default(true)
  GroupExam            GroupExam[]
  ScheduledGroupBuffer ScheduledGroupBuffer?
  User                 User?                 @relation(fields: [userId], references: [id])
  userId               Int?
}

model GroupParticipant {
  id            Int @id @default(autoincrement())
  groupId       Int
  participantId Int

  group Group       @relation(fields: [groupId], references: [id])
  user  Participant @relation(fields: [participantId], references: [id])

  assignedAt DateTime @default(now())
  isActive   Boolean  @default(true)
  User       User?    @relation(fields: [userId], references: [id])
  userId     Int?
  visibility Boolean  @default(true)

  @@unique([groupId, participantId])
}

model GroupExam {
  id         Int @id @default(autoincrement())
  groupId    Int
  examId     Int
  assignedBy Int

  group Group @relation(fields: [groupId], references: [id])
  exam  Exam  @relation(fields: [examId], references: [id])
  admin User  @relation(fields: [assignedBy], references: [id])

  assignedAt DateTime @default(now())

  visibility Boolean @default(true)

  @@unique([groupId, examId])
}

model ScheduledExamBuffer {
  id        Int      @id @default(autoincrement())
  examId    Int      @unique
  exam      Exam     @relation(fields: [examId], references: [id])
  startTime DateTime
  endTime   DateTime
  createdAt DateTime @default(now())
  processed Boolean  @default(false) // To track if it's already pushed to QStash
}

model ScheduledGroupBuffer {
  id        Int      @id @default(autoincrement())
  groupId   Int      @unique
  group     Group    @relation(fields: [groupId], references: [id])
  endDate   DateTime
  createdAt DateTime @default(now())
  processed Boolean  @default(false) // To track if it's already pushed to QStash
}

model ParticipantTracking {
  id            Int         @id @default(autoincrement())
  participantId Int
  participant   Participant @relation(fields: [participantId], references: [id])
  loginTime     DateTime
  logoutTime    DateTime
  spentTime     Int
  createdAt     DateTime    @default(now())
}

model UploadBatch {
  id                Int                 @id @default(autoincrement())
  adminId           Int
  fileName          String
  status            String              @default("PENDING") // PENDING, VALID, IMPORTED, FAILED
  admin             User                @relation(fields: [adminId], references: [id])
  uploadedAt        DateTime            @default(now())
  questions         StagingQuestion[]   @relation("BatchQuestions")
  Question          Question[]
  FileUploadSummary FileUploadSummary[]
}

model UploadParticipantBatch {
  id                 Int                  @id @default(autoincrement())
  adminId            Int
  fileName           String
  status             String               @default("PENDING") // PENDING, VALID, IMPORTED, FAILED
  admin              User                 @relation(fields: [adminId], references: [id])
  uploadedAt         DateTime             @default(now())
  Participant        Participant[]
  StagingParticipant StagingParticipant[]
}

model StagingQuestion {
  id              Int           @id @default(autoincrement())
  adminId         Int
  batchId         Int? // Foreign key pointing to UploadBatch.id
  categoryName    String?
  topicName       String?
  question        String?
  option1         String?
  option2         String?
  option3         String?
  option4         String?
  correctOption   Int?
  difficultyLevel String?
  status          StagingStatus @default(PENDING)
  errorMessage    String?
  createdAt       DateTime      @default(now())

  admin User         @relation(fields: [adminId], references: [id])
  batch UploadBatch? @relation("BatchQuestions", fields: [batchId], references: [id])

  @@index([batchId])
}

enum StagingStatus {
  PENDING
  VALID
  INVALID
  DUPLICATE
  IMPORTED
}

model WordCloudQuestion {
  id        Int      @id @default(autoincrement())
  adminId   Int
  title     String?
  words     String // comma-separated words
  createdAt DateTime @default(now())

  admin         User                @relation(fields: [adminId], references: [id])
  responses     WordCloudResponse[]
  WordFrequency WordFrequency[]
}

model WordCloudResponse {
  id            Int      @id @default(autoincrement())
  participantId Int
  wordCloudId   Int
  responseText  String
  createdAt     DateTime @default(now())

  participant Participant       @relation(fields: [participantId], references: [id])
  wordCloud   WordCloudQuestion @relation(fields: [wordCloudId], references: [id])
}

model WordFrequency {
  id          Int    @id @default(autoincrement())
  word        String
  count       Int    @default(1)
  wordCloudId Int

  wordCloud WordCloudQuestion @relation(fields: [wordCloudId], references: [id])

  @@unique([word, wordCloudId]) // Prevent duplicate word entries per question
}

model StagingParticipant {
  id             Int                     @id @default(autoincrement())
  name           String
  email          String
  mobileNumber   String
  password       String
  batchId        Int?
  organizationId Int
  createdById    Int
  errorMessage   String?
  status         StagingStatus           @default(PENDING)
  createdAt      DateTime                @default(now())
  admin          User                    @relation(fields: [createdById], references: [id])
  batch          UploadParticipantBatch? @relation(fields: [batchId], references: [id])
}

enum ParticipantStagingStatus {
  PENDING
  VALID
  INVALID
  DUPLICATE
  IMPORTED
}

enum UploadType {
  QUESTION_FILE
  PARTICIPANT_FILE
  PARTICIPANT_GROUP_ADD
}

model FileUploadSummary {
  id          Int          @id @default(autoincrement())
  batchId     Int?
  adminId     Int
  type        UploadType
  fileName    String
  inserted    Int
  skipped     Int
  failed      Int
  summaryData Json? // Full structured summary for Excel
  createdAt   DateTime     @default(now())
  admin       User         @relation(fields: [adminId], references: [id])
  batch       UploadBatch? @relation(fields: [batchId], references: [id])
}
